@inject IWheelService _wheelService;

@if(xBoard?.Cards != null)
{
    <div id="pageContainer" class="page">
        <div>
            <div>
                <div id="holder" class="container">
                    <div class="pin">
                        <svg width="11px" height="200px" xmlns="http://www.w3.org/2000/svg">
                            <g fill-rule="evenodd">
                                <g transform="translate(-685, -130)" fill="#DEE2FD">
                                    <g transform="translate(198, 130)">
                                        <path id="ticker" d="M 487 203 L 491 195 L 491 8 L 493 1 L 495 8 L 494 195 L 498 203 L 487 203 Z">
                                        </path>
                                    </g>
                                </g>
                            </g>
                        </svg>
                    </div>

            @foreach(var card in xBoard.Cards)
            {
                 <div @key="card" @ref="@refs[card.Guid.ToString()]" class=@($"card {_animation}") style=@($"background-color: {card.Color};")>
                      <span>
                         <p>@card.Text</p>
                     </span>
                 </div>
            }
        </div>
        </div>
            <MudButton Disabled="@_move" ButtonType="@ButtonType.Button" OnClick="@(async () => await Spin())" Color="Color.Primary">Move</MudButton>
        </div>
        
    </div>
}
else
{
    <p>Loading..</p>
}

@code {
    private string _animation = "";
    private bool _move;

    protected XBoard xBoard = new XBoard();
    private Dictionary<string, ElementReference> refs = new Dictionary<string, ElementReference>();

    protected override async Task OnInitializedAsync()
    {
        await AddMissingCards();
        await base.OnInitializedAsync();
    }

    public async Task Spin()
    {
        _move = true;
        _animation = "containerSpinning";
        StateHasChanged();

        await Task.Delay(TimeSpan.FromSeconds(15)).ContinueWith(_ => 
        {
            _move = false;
            _animation = "";
            StateHasChanged();
        });
    }

    private async Task AddMissingCards()
    {
        if (xBoard.Cards.Count < xBoard.NeededCards)
        {
            var wheelEntries = (await _wheelService.GetNextWheelEntries(xBoard.NeededCards - xBoard.Cards.Count)).ToList();

            var i = xBoard.NeededCards / 2 * -1;
            var cards = wheelEntries.Select(x => new XCard((XCard.CardWidth + 10) * i++, 150, 2, x));

            xBoard.AddCards(cards);
        }
    }
}
